
# Generated by stc version 0.5.0
# date                    : 2015/08/23 15:54:59
# Turbine version         : 0.6.0
# Input filename          : /home/chintan/Desktop/gallery/hello-world/632-app.swift
# Output filename         : /home/chintan/Desktop/gallery/hello-world/./swift-t-632-app.6nE.tic
# STC home                : /home/chintan/Desktop/exm-0.7.0/stc
# Turbine home            : /tmp/exm-install/turbine
# Compiler settings:
# stc.auto-declare              : true
# stc.c_preprocess              : true
# stc.checkpointing             : true
# stc.codegen.no-stack          : true
# stc.codegen.no-stack-vars     : true
# stc.compiler-debug            : true
# stc.debugging                 : COMMENTS
# stc.ic.output-file            : 
# stc.input_filename            : 632-app.swift
# stc.log.file                  : 
# stc.log.trace                 : false
# stc.must_pass_wait_vars       : true
# stc.opt.algebra               : true
# stc.opt.array-build           : true
# stc.opt.batch-refcounts       : true
# stc.opt.cancel-refcounts      : true
# stc.opt.constant-fold         : true
# stc.opt.controlflow-fusion    : true
# stc.opt.dataflow-op-inline    : true
# stc.opt.dead-code-elim        : true
# stc.opt.disable-asserts       : false
# stc.opt.expand-loop-threshold-insts: 256
# stc.opt.expand-loop-threshold-iters: 16
# stc.opt.expand-loops          : false
# stc.opt.finalized-var         : true
# stc.opt.flatten-nested        : true
# stc.opt.full-unroll           : false
# stc.opt.function-inline       : false
# stc.opt.function-inline-threshold: 500
# stc.opt.function-signature    : true
# stc.opt.hoist                 : true
# stc.opt.hoist-refcounts       : true
# stc.opt.loop-simplify         : true
# stc.opt.max-iterations        : 10
# stc.opt.merge-refcounts       : true
# stc.opt.piggyback-refcounts   : true
# stc.opt.pipeline              : false
# stc.opt.propagate-aliases     : true
# stc.opt.reorder-insts         : false
# stc.opt.shared-constants      : true
# stc.opt.unroll-loop-threshold-insts: 192
# stc.opt.unroll-loop-threshold-iters: 8
# stc.opt.unroll-loops          : true
# stc.opt.value-number          : true
# stc.opt.wait-coalesce         : true
# stc.output_filename           : ./swift-t-632-app.6nE.tic
# stc.preproc.force-cpp         : false
# stc.preproc.force-gcc         : false
# stc.preprocess_only           : false
# stc.profile                   : false
# stc.refcounting               : true
# stc.rpath                     : 
# stc.soft-target               : true
# stc.stc_home                  : /home/chintan/Desktop/exm-0.7.0/stc
# stc.turbine.separate-engine   : false
# stc.turbine.version           : 0.6.0
# stc.turbine_home              : /tmp/exm-install/turbine
# stc.version                   : 0.5.0

# Metadata:

package require turbine 0.6.0
namespace import turbine::*


proc swift:constants {  } {
    turbine::c::log "function:swift:constants"
}


proc f:split1 { stack u:out1 u:inp v:location v:soft_location } {
    turbine::c::log "enter function: split1"
    # Var: $boolean v:mapped_out1 OPT_TEMPORARY
    turbine::file_read_refcount_incr ${u:inp} 2
    set filename:inp [ turbine::get_file_path ${u:inp} ]
    set v:mapped_out1 [ turbine::is_file_mapped ${u:out1} ]
    if { ${v:mapped_out1} } {
        set filename:out1 [ turbine::get_file_path ${u:out1} ]
    } else {
        # Var: $string optf:out1 FILENAME_OF [file:out1]
        set optf:out1 [ turbine::mktemp ]
        turbine::set_filename_val ${u:out1} ${optf:out1}
        set filename:out1 [ turbine::get_file_path ${u:out1} ]
    }
    turbine::read_refcount_incr ${filename:out1} 1
    turbine::rule [ list ${filename:inp} ${filename:out1} [ turbine::get_file_td ${u:inp} ] ] "split1-app-leaf0 ${stack} {${filename:inp}} {${filename:out1}} ${v:mapped_out1} {${u:inp}} {${u:out1}}" [ expr { (${v:soft_location}) ? ("soft_target") : ("target") } ] ${v:location}
}


proc split1-app-leaf0 { stack filename:inp filename:out1 v:mapped_out1 u:inp u:out1 } {
    # Var: $string v:__filename:inp VALUE_OF [string:__filename:inp] 632-app.swift:split1():3:16
    # Var: $string v:__filename:out1 VALUE_OF [string:__filename:out1] 632-app.swift:split1():3:16
    # Var: $file v:inp VALUE_OF [file:inp] 632-app.swift:split1():3:16
    # Var: $file v:out1 VALUE_OF [file:out1] 632-app.swift:split1():3:16
    # Var: $boolean v:2 EXPR_TEMPORARY 632-app.swift:split1():3:16
    set v:__filename:inp [ turbine::retrieve_string ${filename:inp} ]
    set v:__filename:out1 [ turbine::retrieve_string ${filename:out1} CACHED 1 ]
    set v:inp [ turbine::retrieve_file ${u:inp} CACHED 2 ]
    if { ${v:mapped_out1} } {
        set tcltmp:init_rc 2
    } else {
        set tcltmp:init_rc 1
    }
    set v:out1 [ turbine::create_local_file_ref ${v:__filename:out1} ${tcltmp:init_rc} ]
    turbine::c::log [ list exec: ./632-split.sh ${v:__filename:inp} ${v:__filename:out1} [ dict create ] ]
    turbine::exec_external "./632-split.sh" [ dict create ] ${v:__filename:inp} ${v:__filename:out1}
    set v:2 [ expr { ! ${v:mapped_out1} } ]
    turbine::store_file ${u:out1} v:out1 ${v:2}
    turbine::decr_local_file_refcount v:out1
}


proc f:sort { stack u:o u:i u:j v:location v:soft_location } {
    turbine::c::log "enter function: sort"
    # Var: $boolean v:mapped_o OPT_TEMPORARY
    turbine::file_read_refcount_incr ${u:i} 2
    turbine::file_read_refcount_incr ${u:j} 2
    set filename:i [ turbine::get_file_path ${u:i} ]
    set filename:j [ turbine::get_file_path ${u:j} ]
    set v:mapped_o [ turbine::is_file_mapped ${u:o} ]
    if { ${v:mapped_o} } {
        set filename:o [ turbine::get_file_path ${u:o} ]
    } else {
        # Var: $string optf:o FILENAME_OF [file:o]
        set optf:o [ turbine::mktemp ]
        turbine::set_filename_val ${u:o} ${optf:o}
        set filename:o [ turbine::get_file_path ${u:o} ]
    }
    turbine::read_refcount_incr ${filename:o} 1
    turbine::rule [ list ${filename:i} ${filename:j} ${filename:o} [ turbine::get_file_td ${u:i} ] [ turbine::get_file_td ${u:j} ] ] "sort-app-leaf0 ${stack} {${filename:i}} {${filename:j}} {${filename:o}} ${v:mapped_o} {${u:i}} {${u:j}} {${u:o}}" [ expr { (${v:soft_location}) ? ("soft_target") : ("target") } ] ${v:location}
}


proc sort-app-leaf0 { stack filename:i filename:j filename:o v:mapped_o u:i u:j u:o } {
    # Var: $string v:__filename:i VALUE_OF [string:__filename:i] 632-app.swift:sort():13:27
    # Var: $string v:__filename:j VALUE_OF [string:__filename:j] 632-app.swift:sort():13:27
    # Var: $string v:__filename:o VALUE_OF [string:__filename:o] 632-app.swift:sort():13:27
    # Var: $file v:i VALUE_OF [file:i] 632-app.swift:sort():13:27
    # Var: $file v:j VALUE_OF [file:j] 632-app.swift:sort():13:27
    # Var: $file v:o VALUE_OF [file:o] 632-app.swift:sort():13:27
    # Var: $boolean v:2 EXPR_TEMPORARY 632-app.swift:sort():13:27
    set v:__filename:i [ turbine::retrieve_string ${filename:i} ]
    set v:__filename:j [ turbine::retrieve_string ${filename:j} ]
    set v:__filename:o [ turbine::retrieve_string ${filename:o} CACHED 1 ]
    set v:i [ turbine::retrieve_file ${u:i} CACHED 2 ]
    set v:j [ turbine::retrieve_file ${u:j} CACHED 2 ]
    if { ${v:mapped_o} } {
        set tcltmp:init_rc 2
    } else {
        set tcltmp:init_rc 1
    }
    set v:o [ turbine::create_local_file_ref ${v:__filename:o} ${tcltmp:init_rc} ]
    turbine::c::log [ list exec: sort "-mn" ${v:__filename:i} ${v:__filename:j} [ dict create "stdout" ${v:__filename:o} ] ]
    turbine::exec_external "sort" [ dict create "stdout" ${v:__filename:o} ] "-mn" ${v:__filename:i} ${v:__filename:j}
    set v:2 [ expr { ! ${v:mapped_o} } ]
    turbine::store_file ${u:o} v:o ${v:2}
    turbine::decr_local_file_refcount v:o
}


proc f:merge-1 { stack u:o v:i:1 v:j:1 } {
    turbine::c::log "enter function: merge-1"
    turbine::rule [ list ] "merge-async_op-minus_int ${stack} ${v:i:1} ${v:j:1} {${u:o}}"
}


proc merge-async_op-minus_int { stack v:i:1 v:j:1 u:o } {
    # Var: $int v:t:1 VALUE_OF [int:__t:1]
    # Var: $boolean v:t:0 VALUE_OF [boolean:__t:0]
    set v:t:1 [ expr { ${v:j:1} - ${v:i:1} } ]
    set v:t:0 [ expr { ${v:t:1} == 1 } ]
    if { ${v:t:0} } {
        # Var: file u:fi 632-app.swift:merge():20:4
        # Var: file u:fj 632-app.swift:merge():21:4
        # Var: $string v:t:3 VALUE_OF [string:__t:3]
        # Var: $file v:fi VALUE_OF [file:fi]
        # Var: $string v:t:5 VALUE_OF [string:__t:5]
        # Var: $file v:fj VALUE_OF [file:fj]
        turbine::allocate_file u:fi 0 1 1 1
        turbine::allocate_file u:fj 0 1 1 2
        f:sort ${stack} ${u:o} ${u:fi} ${u:fj} -100 0
        set v:t:3 [ eval format [ list "data-%i.txt" ${v:i:1} ] ]
        set v:fi [ turbine::input_file_local ${v:t:3} ]
        turbine::store_file ${u:fi} v:fi 1
        set v:t:5 [ eval format [ list "data-%i.txt" ${v:j:1} ] ]
        set v:fj [ turbine::input_file_local ${v:t:5} ]
        turbine::store_file ${u:fj} v:fj 1
        turbine::decr_local_file_refcount v:fi
        turbine::decr_local_file_refcount v:fj
        turbine::file_read_refcount_decr ${u:fj} 1
        turbine::file_read_refcount_decr ${u:fi} 1
    } else {
        # Var: file t:10 EXPR_TEMPORARY 632-app.swift:merge():28:13
        # Var: file t:14 EXPR_TEMPORARY 632-app.swift:merge():28:29
        # Var: $int v:d VALUE_OF [int:d]
        # Var: $int v:m VALUE_OF [int:m]
        # Var: $int v:t:12 VALUE_OF [int:__t:12]
        # Var: $int v:t:11 VALUE_OF [int:__t:11]
        turbine::allocate_file t:10 0 1 1 3
        turbine::allocate_file t:14 0 1 1 4
        f:sort ${stack} ${u:o} ${t:10} ${t:14} -100 0
        set v:d [ expr { ${v:t:1} + 1 } ]
        set v:m [ turbine::divide_integer_impl ${v:d} 2 ]
        set v:t:12 [ expr { ${v:i:1} + ${v:m} } ]
        set v:t:11 [ expr { ${v:t:12} - 1 } ]
        set tcltmp:prio [ turbine::get_priority ]
        turbine::set_priority ${tcltmp:prio}
        adlb::spawn 0 "f:merge-1 ${stack} {${t:10}} ${v:i:1} ${v:t:11}"
        turbine::reset_priority
        set tcltmp:prio [ turbine::get_priority ]
        turbine::set_priority ${tcltmp:prio}
        adlb::spawn 0 "f:merge-1 ${stack} {${t:14}} ${v:t:12} ${v:j:1}"
        turbine::reset_priority
    }
    turbine::file_read_refcount_decr ${u:o} 1
}


proc swift:main {  } {
    turbine::c::log "enter function: main"
    set stack 0
    # Var: file u:result 632-app.swift:main():57:13
    turbine::allocate_file u:result 1 1 1 5
    turbine::set_filename_val ${u:result} "sorted.txt"
    set tcltmp:prio [ turbine::get_priority ]
    turbine::set_priority ${tcltmp:prio}
    adlb::spawn 0 "f:merge-1 ${stack} {${u:result}} 0 9"
    turbine::reset_priority
    main-range0:outer ${stack} 0 9 1
}


proc main-range0:outer { stack tcltmp:lo tcltmp:hi tcltmp:inc } {
    if { [ expr { ${tcltmp:lo} > ${tcltmp:hi} } ] } {
        return
    }
    while {1} {
        set tcltmp:itersleft [ expr { max(0,(${tcltmp:hi} - ${tcltmp:lo}) / ${tcltmp:inc} + 1) } ]
        if { [ expr { ${tcltmp:itersleft} <= 64 } ] } {
            main-range0:inner ${stack} ${tcltmp:lo} ${tcltmp:hi} ${tcltmp:inc}
            return
        } else {
            set tcltmp:skip [ expr { ${tcltmp:inc} * max(64,((${tcltmp:itersleft} - 1) / 16) + 1) } ]
            for { set tcltmp:splitstart [ expr { ${tcltmp:lo} + ${tcltmp:skip} } ] } { ${tcltmp:splitstart} <= ${tcltmp:hi} } { incr tcltmp:splitstart ${tcltmp:skip} } {
                set tcltmp:splitend [ expr { min(${tcltmp:hi},${tcltmp:splitstart} + ${tcltmp:skip} - 1) } ]
                set tcltmp:prio [ turbine::get_priority ]
                turbine::set_priority ${tcltmp:prio}
                adlb::spawn 0 "main-range0:outer ${stack} ${tcltmp:splitstart} ${tcltmp:splitend} ${tcltmp:inc}"
                turbine::reset_priority
            }
            set tcltmp:hi [ expr { ${tcltmp:lo} + ${tcltmp:skip} - 1 } ]
        }
    }
}


proc main-range0:inner { stack tcltmp:lo tcltmp:hi tcltmp:inc } {
    for { set v:x0 ${tcltmp:lo} } { ${v:x0} <= ${tcltmp:hi} } { incr v:x0 ${tcltmp:inc} } {
        # Var: file u:infile 632-app.swift:main():47:2
        # Var: file u:tail 632-app.swift:main():49:12
        # Var: $string v:filename2 VALUE_OF [string:filename2]
        # Var: $file v:infile VALUE_OF [file:infile]
        # Var: $string v:filename1 VALUE_OF [string:filename1]
        turbine::allocate_file u:infile 0 1 1 6
        turbine::allocate_file u:tail 1 1 1 7
        set v:filename2 [ eval format [ list "input/data%.2d" ${v:x0} ] ]
        set v:infile [ turbine::input_file_local ${v:filename2} ]
        turbine::store_file ${u:infile} v:infile 1
        set v:filename1 [ eval format [ list "output/data%.2d.txt" ${v:x0} ] ]
        turbine::set_filename_val ${u:tail} ${v:filename1}
        f:split1 ${stack} ${u:tail} ${u:infile} -100 0
        turbine::decr_local_file_refcount v:infile
        turbine::file_read_refcount_decr ${u:tail} 1
        turbine::file_read_refcount_decr ${u:infile} 1
    }
}

turbine::defaults
turbine::init $servers "Swift"
turbine::enable_read_refcount
adlb::add_debug_symbol 1 "fi" "632-app:merge():20:4"
adlb::add_debug_symbol 2 "fj" "632-app:merge():21:4"
adlb::add_debug_symbol 3 "__t:10" "632-app:merge():28:13"
adlb::add_debug_symbol 4 "__t:14" "632-app:merge():28:29"
adlb::add_debug_symbol 5 "result" "632-app:main():57:13"
adlb::add_debug_symbol 6 "infile" "632-app:main():47:2"
adlb::add_debug_symbol 7 "tail" "632-app:main():49:12"
turbine::check_constants "WORKER\[WORKER\]" ${turbine::WORK_TASK} 0 "CONTROL" ${turbine::WORK_TASK} 0 "ADLB_RANK_ANY" ${adlb::RANK_ANY} -100
turbine::start swift:main swift:constants
turbine::finalize
