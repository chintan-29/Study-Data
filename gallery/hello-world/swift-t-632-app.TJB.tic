
# Generated by stc version 0.5.0
# date                    : 2015/08/23 14:24:02
# Turbine version         : 0.6.0
# Input filename          : /home/chintan/Desktop/gallery/hello-world/632-app.swift
# Output filename         : /home/chintan/Desktop/gallery/hello-world/./swift-t-632-app.TJB.tic
# STC home                : /home/chintan/Desktop/exm-0.7.0/stc
# Turbine home            : /tmp/exm-install/turbine
# Compiler settings:
# stc.auto-declare              : true
# stc.c_preprocess              : true
# stc.checkpointing             : true
# stc.codegen.no-stack          : true
# stc.codegen.no-stack-vars     : true
# stc.compiler-debug            : true
# stc.debugging                 : COMMENTS
# stc.ic.output-file            : 
# stc.input_filename            : 632-app.swift
# stc.log.file                  : 
# stc.log.trace                 : false
# stc.must_pass_wait_vars       : true
# stc.opt.algebra               : true
# stc.opt.array-build           : true
# stc.opt.batch-refcounts       : true
# stc.opt.cancel-refcounts      : true
# stc.opt.constant-fold         : true
# stc.opt.controlflow-fusion    : true
# stc.opt.dataflow-op-inline    : true
# stc.opt.dead-code-elim        : true
# stc.opt.disable-asserts       : false
# stc.opt.expand-loop-threshold-insts: 256
# stc.opt.expand-loop-threshold-iters: 16
# stc.opt.expand-loops          : false
# stc.opt.finalized-var         : true
# stc.opt.flatten-nested        : true
# stc.opt.full-unroll           : false
# stc.opt.function-inline       : false
# stc.opt.function-inline-threshold: 500
# stc.opt.function-signature    : true
# stc.opt.hoist                 : true
# stc.opt.hoist-refcounts       : true
# stc.opt.loop-simplify         : true
# stc.opt.max-iterations        : 10
# stc.opt.merge-refcounts       : true
# stc.opt.piggyback-refcounts   : true
# stc.opt.pipeline              : false
# stc.opt.propagate-aliases     : true
# stc.opt.reorder-insts         : false
# stc.opt.shared-constants      : true
# stc.opt.unroll-loop-threshold-insts: 192
# stc.opt.unroll-loop-threshold-iters: 8
# stc.opt.unroll-loops          : true
# stc.opt.value-number          : true
# stc.opt.wait-coalesce         : true
# stc.output_filename           : ./swift-t-632-app.TJB.tic
# stc.preproc.force-cpp         : false
# stc.preproc.force-gcc         : false
# stc.preprocess_only           : false
# stc.profile                   : false
# stc.refcounting               : true
# stc.rpath                     : 
# stc.soft-target               : true
# stc.stc_home                  : /home/chintan/Desktop/exm-0.7.0/stc
# stc.turbine.separate-engine   : false
# stc.turbine.version           : 0.6.0
# stc.turbine_home              : /tmp/exm-install/turbine
# stc.version                   : 0.5.0

# Metadata:

package require turbine 0.6.0
namespace import turbine::*


proc swift:constants {  } {
    turbine::c::log "function:swift:constants"
    global c:i_2
    turbine::allocate_custom c:i_2 integer 1 1 4 1
    turbine::store_integer ${c:i_2} 2
}


proc f:split { stack u:out1 u:out2 u:inp u:lines v:location v:soft_location } {
    turbine::c::log "enter function: split"
    # Var: $boolean v:mapped_out1 OPT_TEMPORARY
    # Var: $boolean v:mapped_out2 OPT_TEMPORARY
    turbine::read_refcount_incr ${u:lines} 1
    turbine::file_read_refcount_incr ${u:inp} 2
    set filename:inp [ turbine::get_file_path ${u:inp} ]
    set v:mapped_out1 [ turbine::is_file_mapped ${u:out1} ]
    if { ${v:mapped_out1} } {
        set filename:out1 [ turbine::get_file_path ${u:out1} ]
    } else {
        # Var: $string optf:out1 FILENAME_OF [file:out1]
        set optf:out1 [ turbine::mktemp ]
        turbine::set_filename_val ${u:out1} ${optf:out1}
        set filename:out1 [ turbine::get_file_path ${u:out1} ]
    }
    turbine::read_refcount_incr ${filename:out1} 1
    set v:mapped_out2 [ turbine::is_file_mapped ${u:out2} ]
    if { ${v:mapped_out2} } {
        set filename:out2 [ turbine::get_file_path ${u:out2} ]
    } else {
        # Var: $string optf:out2 FILENAME_OF [file:out2]
        set optf:out2 [ turbine::mktemp ]
        turbine::set_filename_val ${u:out2} ${optf:out2}
        set filename:out2 [ turbine::get_file_path ${u:out2} ]
    }
    turbine::read_refcount_incr ${filename:out2} 1
    turbine::rule [ list ${filename:inp} ${filename:out1} ${filename:out2} [ turbine::get_file_td ${u:inp} ] ${u:lines} ] "split-app-leaf0 ${stack} {${filename:inp}} {${filename:out1}} {${filename:out2}} ${v:mapped_out1} ${v:mapped_out2} {${u:inp}} {${u:lines}} {${u:out1}} {${u:out2}}" [ expr { (${v:soft_location}) ? ("soft_target") : ("target") } ] ${v:location}
}


proc split-app-leaf0 { stack filename:inp filename:out1 filename:out2 v:mapped_out1 v:mapped_out2 u:inp u:lines u:out1 u:out2 } {
    # Var: $string v:__filename:inp VALUE_OF [string:__filename:inp] 632-app.swift:split():4:26
    # Var: $int v:lines VALUE_OF [int:lines] 632-app.swift:split():4:26
    # Var: $string v:__filename:out1 VALUE_OF [string:__filename:out1] 632-app.swift:split():4:26
    # Var: $string v:__filename:out2 VALUE_OF [string:__filename:out2] 632-app.swift:split():4:26
    # Var: $file v:inp VALUE_OF [file:inp] 632-app.swift:split():4:26
    # Var: $file v:out1 VALUE_OF [file:out1] 632-app.swift:split():4:26
    # Var: $file v:out2 VALUE_OF [file:out2] 632-app.swift:split():4:26
    # Var: $boolean v:3 EXPR_TEMPORARY 632-app.swift:split():4:26
    # Var: $boolean v:5 EXPR_TEMPORARY 632-app.swift:split():4:26
    set v:__filename:inp [ turbine::retrieve_string ${filename:inp} ]
    set v:lines [ turbine::retrieve_integer ${u:lines} CACHED 1 ]
    set v:__filename:out1 [ turbine::retrieve_string ${filename:out1} CACHED 1 ]
    set v:__filename:out2 [ turbine::retrieve_string ${filename:out2} CACHED 1 ]
    set v:inp [ turbine::retrieve_file ${u:inp} CACHED 2 ]
    if { ${v:mapped_out1} } {
        set tcltmp:init_rc 2
    } else {
        set tcltmp:init_rc 1
    }
    set v:out1 [ turbine::create_local_file_ref ${v:__filename:out1} ${tcltmp:init_rc} ]
    if { ${v:mapped_out2} } {
        set tcltmp:init_rc 2
    } else {
        set tcltmp:init_rc 1
    }
    set v:out2 [ turbine::create_local_file_ref ${v:__filename:out2} ${tcltmp:init_rc} ]
    turbine::c::log [ list exec: ./632-split.sh ${v:__filename:inp} ${v:lines} ${v:__filename:out1} ${v:__filename:out2} [ dict create ] ]
    turbine::exec_external "./632-split.sh" [ dict create ] ${v:__filename:inp} ${v:lines} ${v:__filename:out1} ${v:__filename:out2}
    set v:3 [ expr { ! ${v:mapped_out1} } ]
    turbine::store_file ${u:out1} v:out1 ${v:3}
    set v:5 [ expr { ! ${v:mapped_out2} } ]
    turbine::store_file ${u:out2} v:out2 ${v:5}
    turbine::decr_local_file_refcount v:out1
    turbine::decr_local_file_refcount v:out2
}


proc swift:main {  } {
    turbine::c::log "enter function: main"
    set stack 0
    # Var: int c:i_2 OPT_TEMPORARY
    global c:i_2
    # Var: file u:infile 632-app.swift:main():10:4
    # Var: file u:head 632-app.swift:main():11:4
    # Var: file u:tail 632-app.swift:main():11:20
    # Var: $file v:infile VALUE_OF [file:infile]
    turbine::allocate_file u:infile 0 1 1 1
    turbine::allocate_file u:head 0 1 1 2
    turbine::allocate_file u:tail 1 1 1 3
    set v:infile [ turbine::input_file_local "lines.txt" ]
    turbine::store_file ${u:infile} v:infile 1
    turbine::set_filename_val ${u:tail} "tail.txt"
    f:split ${stack} ${u:head} ${u:tail} ${u:infile} ${c:i_2} -100 0
    turbine::decr_local_file_refcount v:infile
    turbine::file_read_refcount_decr ${u:tail} 1
    turbine::file_read_refcount_decr ${u:head} 1
    turbine::file_read_refcount_decr ${u:infile} 1
}

turbine::defaults
turbine::init $servers "Swift"
turbine::enable_read_refcount
adlb::add_debug_symbol 1 "infile" "632-app:main():10:4"
adlb::add_debug_symbol 2 "head" "632-app:main():11:4"
adlb::add_debug_symbol 3 "tail" "632-app:main():11:20"
adlb::add_debug_symbol 4 "__c:i_2" ""
turbine::check_constants "WORKER\[WORKER\]" ${turbine::WORK_TASK} 0 "CONTROL" ${turbine::WORK_TASK} 0 "ADLB_RANK_ANY" ${adlb::RANK_ANY} -100
turbine::start swift:main swift:constants
turbine::finalize
